# CLAUDE.md

Этот файл содержит рекомендации для Claude Code (claude.ai/code) при работе с кодом в этом репозитории.

## Обзор проекта

**openrouter-cli-chat** — это CLI-приложение, которое подключается к OpenRouter API LLM и позволяет ему взаимодействовать с локальными серверами Model Context Protocol (MCP). Архитектура обеспечивает цикл чата, где LLM может получать запросы пользователя, вызывать инструменты с серверов MCP и предоставлять разумные ответы на основе выходных данных инструментов.

### Ключевые особенности

- ✅ Интеграция с OpenRouter API
- ✅ Поддержка локальных MCP серверов
- ✅ Система инструментов для расширения функциональности
- ✅ Интерактивный CLI чат-интерфейс
- ✅ TypeScript для типобезопасности

## Часто используемые команды

### Сборка проекта

```bash
npm run build
```

Компилирует TypeScript в JavaScript (выходной файл: `dist/`)

### Режим разработки

Запускает приложение напрямую с помощью ts-node (требует скомпилированный MCP сервер)

### Проверка кода (Linting)

```bash
npm run lint
```

Проверяет код с помощью ESLint

```bash
npm run lint:fix
```

Автоматически исправляет проблемы с линтингом

### Форматирование кода

```bash
npm run format
```

Форматирует код с помощью Prettier

```bash
npm run format:check
```

Проверяет, правильно ли отформатирован код

## Архитектура

### Трёхуровневая архитектура

1. **MCP Client** (`src/mcp-clients/index.ts`)
   - Центральный оркестратор, управляющий циклом взаимодействия LLM-MCP
   - Подключается к серверам MCP через stdio транспорт
   - Реализует цикл чата, который принимает запросы пользователя и возвращает ответы
   - Обрабатывает извлечение определений инструментов и ресурсов из серверов MCP
   - Управляет состоянием разговора с объектами `MessageParam`
   - Загружает доступные ресурсы при подключении к серверу

2. **OpenRouter LLM Client** (`src/openrouter/index.ts`)
   - Обёртка вокруг OpenRouter SDK
   - По умолчанию использует `mistralai/mistral-7b-instruct` (настраивается)
   - Поддерживает определения инструментов для вызова функций
   - Отправляет сообщения и получает ответы с дополнительными вызовами инструментов

3. **MCP Servers** (`src/mcp-servers/`)
   - Независимые процессы, которые предоставляют инструменты и ресурсы через протокол MCP
   - В настоящее время включает `file-mcp-server` для работы с локальными документами
   - Использует stdio транспорт для связи с клиентом
   - **Инструменты**: `get_user_docs` читает файлы, `edit_user_docs` редактирует файлы
   - **Ресурсы**: регистрирует документы из `src/mcp-servers/file-mcp-server/docs/` как ресурсы MCP для автокомплита

### Поток данных

```
Ввод пользователя
    ↓
MCPClient.chatLoop() (чтение через readline)
    ↓
MCPClient.processQuery()
    ↓
OpenRouterClient.sendMessage() → LLM решает, нужен ли инструмент
    ↓
Если вызов инструмента → MCPClient вызывает инструмент MCP сервера
    ↓
Результат инструмента → Отправляется обратно LLM для финального ответа
    ↓
Вывод в консоль
```

### Поток выполнения инструментов

1. Пользователь предоставляет запрос
2. MCP Client извлекает доступные инструменты из подключённого MCP сервера
3. Инструменты форматируются как `ToolDefinitionJson` и отправляются LLM
4. LLM может вызывать инструменты через функциональный вызов
5. Аргументы инструмента анализируются и передаются в `mcp.callTool()`
6. Результат добавляется в историю сообщений и отправляется обратно LLM
7. LLM генерирует финальный ответ на основе выходных данных инструмента

### Система ресурсов MCP

MCP Server поддерживает регистрацию ресурсов для удобного доступа к документам:

1. При запуске MCP сервера все файлы из `docs/` директории регистрируются как ресурсы
2. Каждый документ получает URI вида `file://docs/{document_name}`
3. MCP Client загружает список доступных ресурсов при подключении
4. Ресурсы используются для автокомплита в будущем (при поддержке `@` префикса в CLI)
5. Ресурсы могут быть динамически считаны через `server.resource()` метод

## Установка и настройка

1. **Конфигурация окружения**
   - Скопируйте `.env.example` в `.env`
   - Установите `OPENROUTER_API_KEY` с вашим API ключом
   - Приложение выбросит ошибку если ключ отсутствует при запуске

2. **Сборка MCP сервера**
   - Выполните `npm run build` перед `npm run dev`
   - Приложение ожидает скомпилированный JS по пути `dist/mcp-servers/file-mcp-server/index.js`

3. **Запуск приложения**
   - Выполните `npm run dev`
   - Приложение подключится к MCP серверу
   - Пользователь может взаимодействовать через приглашение readline

## Основные зависимости

- **@modelcontextprotocol/sdk**: реализация протокола MCP (клиент + сервер)
- **@openrouter/sdk**: клиент API OpenRouter
- **zod**: валидация схем входных данных инструментов
- **dotenv**: управление переменными окружения

## Важные заметки

- MCP клиент использует **stdio транспорт**, что означает, что серверы MCP порождаются как дочерние процессы и взаимодействуют через stdin/stdout
- Регистрация инструментов в серверах MCP использует схемы Zod для валидации входных данных
- Приложение работает до тех пор, пока пользователь не введёт `exit` в цикле чата
- Все процессы серверов MCP должны быть должным образом очищены через `MCPClient.cleanup()`
- Документы для file-mcp-server должны размещаться в `src/mcp-servers/file-mcp-server/docs/`

## Разработка

При добавлении новых функций или изменении архитектуры, следуйте этим принципам:

- Поддерживайте типобезопасность с помощью TypeScript
- Используйте Zod для валидации входных данных инструментов
- Логируйте значительные события для отладки
- Тестируйте интеграцию с MCP протоколом
- Соблюдайте стиль кода проекта (ESLint + Prettier)
